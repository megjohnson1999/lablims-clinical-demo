import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Button,
  Paper,
  Grid,
  TextField,
  MenuItem,
  CircularProgress,
  Alert,
  IconButton,
  Autocomplete,
} from '@mui/material';
import {
  Save as SaveIcon,
  ArrowBack as ArrowBackIcon,
} from '@mui/icons-material';
import { useParams, Link, useNavigate, useLocation } from 'react-router-dom';
import { projectAPI, collaboratorAPI } from '../../services/api';
import { cleanFormData } from '../../utils/helpers';
import { toast } from 'react-toastify';
import useAutoGeneratedId from '../../hooks/useAutoGeneratedId';
import AutoGeneratedIdField from '../common/AutoGeneratedIdField';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';

const ProjectForm = () => {
  const { id } = useParams();
  const location = useLocation();
  const isEditing = Boolean(id);
  const [formData, setFormData] = useState({
    collaborator_id: location.state?.collaborator_id || '',
    disease: '',
    specimen_type: '',
    source: '',
    date_received: null,
    feedback_date: null,
    comments: '',
  });
  const [collaborators, setCollaborators] = useState([]);
  const [collaboratorOptions, setCollaboratorOptions] = useState([]);
  const [collaboratorLoading, setCollaboratorLoading] = useState(false);
  const [loading, setLoading] = useState(false);
  const [fetchingData, setFetchingData] = useState(true);
  const [error, setError] = useState('');
  const navigate = useNavigate();
  
  // Hook for auto-generated ID
  const { 
    id: previewId, 
    nextId, 
    loading: idLoading, 
    error: idError, 
    refetch: refetchId,
    generateActualId
  } = useAutoGeneratedId('project', isEditing);

  // Search collaborators function
  const searchCollaborators = async (searchTerm) => {
    if (!searchTerm || searchTerm.length < 2) {
      setCollaboratorOptions([]);
      return;
    }
    
    setCollaboratorLoading(true);
    try {
      const response = await collaboratorAPI.getAll(`?search=${encodeURIComponent(searchTerm)}&limit=20`);
      setCollaboratorOptions(Array.isArray(response.data.collaborators) ? response.data.collaborators : []);
    } catch (err) {
      console.error('Error searching collaborators', err);
      setCollaboratorOptions([]);
    } finally {
      setCollaboratorLoading(false);
    }
  };

  useEffect(() => {
    // No need to fetch all collaborators upfront - will search as user types

    if (isEditing) {
      const fetchProject = async () => {
        try {
          const response = await projectAPI.getById(id);
          const projectData = response.data;
          
          // Format dates for form inputs
          if (projectData.date_received) {
            projectData.date_received = new Date(projectData.date_received);
          }
          
          if (projectData.feedback_date) {
            projectData.feedback_date = new Date(projectData.feedback_date);
          }
          
          setFormData({
            ...formData,
            ...projectData,
          });
        } catch (err) {
          console.error('Error fetching project', err);
          setError('Failed to load project details');
        } finally {
          setFetchingData(false);
        }
      };

      fetchProject();
    } else {
      setFetchingData(false);
    }
  }, [id, isEditing]);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData({
      ...formData,
      [name]: value,
    });
  };

  const handleDateChange = (name, date) => {
    setFormData({
      ...formData,
      [name]: date,
    });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    // Data validation
    if (!formData.collaborator_id) {
      setError('Please select a collaborator');
      setLoading(false);
      return;
    }

    try {
      const cleanedData = cleanFormData(formData);
      
      if (isEditing) {
        await projectAPI.update(id, cleanedData);
        toast.success('Project updated successfully');
      } else {
        // Backend now generates ID at creation time
        const response = await projectAPI.create(cleanedData);
        const createdProject = response.data || response;
        toast.success(`Project created successfully with ID ${createdProject.project_number}`);
      }
      
      navigate('/projects');
    } catch (err) {
      console.error('Error saving project', err);
      setError('Failed to save project: ' + (err.response?.data?.msg || err.message));
      setLoading(false);
    }
  };

  if (fetchingData) {
    return (
      <Box display="flex" justifyContent="center" my={4}>
        <CircularProgress />
      </Box>
    );
  }

  return (
    <Box className="project-form page-container">
      <Box display="flex" alignItems="center" mb={3}>
        <IconButton
          component={Link}
          to="/projects"
          sx={{ mr: 1 }}
        >
          <ArrowBackIcon />
        </IconButton>
        <Typography variant="h4" component="h1">
          {isEditing ? 'Edit Project' : 'New Project'}
        </Typography>
      </Box>

      {error && (
        <Alert severity="error" sx={{ mb: 3 }}>
          {error}
        </Alert>
      )}

      <Paper sx={{ p: 3 }}>
        <form onSubmit={handleSubmit}>
          <Grid container spacing={3}>
            {!isEditing && (
              <Grid item xs={12} md={6}>
                <AutoGeneratedIdField
                  label="Project Number"
                  value={previewId}
                  nextId={nextId}
                  loading={idLoading}
                  error={idError}
                  onRefresh={refetchId}
                  isEditMode={isEditing}
                  helperText="Sequential number assigned to this project upon creation"
                />
              </Grid>
            )}
            
            <Grid item xs={12}>
              <Autocomplete
                fullWidth
                options={collaboratorOptions}
                getOptionLabel={(option) => `#${option.collaborator_number} - ${option.pi_name}, ${option.pi_institute}`}
                value={collaboratorOptions.find(c => c.id === formData.collaborator_id) || 
                       collaborators.find(c => c.id === formData.collaborator_id) || null}
                onChange={(event, newValue) => {
                  setFormData(prev => ({
                    ...prev,
                    collaborator_id: newValue ? newValue.id : ''
                  }));
                  // Store selected collaborator for display
                  if (newValue) {
                    setCollaborators([newValue]);
                  }
                }}
                onInputChange={(event, newInputValue) => {
                  searchCollaborators(newInputValue);
                }}
                loading={collaboratorLoading}
                renderInput={(params) => (
                  <TextField
                    {...params}
                    label="Collaborator *"
                    required
                    helperText="Search by name, institution, or collaborator number (minimum 2 characters)"
                    placeholder="Type to search collaborators..."
                    InputProps={{
                      ...params.InputProps,
                      endAdornment: (
                        <>
                          {collaboratorLoading ? <CircularProgress color="inherit" size={20} /> : null}
                          {params.InputProps.endAdornment}
                        </>
                      ),
                    }}
                  />
                )}
                noOptionsText="Type to search collaborators..."
                filterOptions={(x) => x} // Disable client-side filtering since we're doing server-side search
              />
            </Grid>
            
            
            <Grid item xs={12} md={6}>
              <TextField
                fullWidth
                label="Disease"
                name="disease"
                value={formData.disease}
                onChange={handleChange}
                helperText="Enter the disease or condition being studied"
              />
            </Grid>
            
            <Grid item xs={12} md={6}>
              <TextField
                fullWidth
                label="Specimen Type"
                name="specimen_type"
                value={formData.specimen_type}
                onChange={handleChange}
                helperText="Enter the type of specimens in this project"
              />
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Source"
                name="source"
                value={formData.source}
                onChange={handleChange}
                helperText="Enter the source of the specimens"
              />
            </Grid>
            
            <Grid item xs={12} md={6}>
              <LocalizationProvider dateAdapter={AdapterDateFns}>
                <DatePicker
                  label="Date Received"
                  value={formData.date_received}
                  onChange={(date) => handleDateChange('date_received', date)}
                  slotProps={{
                    textField: {
                      fullWidth: true,
                      helperText: 'Enter the date when specimens were received'
                    }
                  }}
                />
              </LocalizationProvider>
            </Grid>
            
            <Grid item xs={12} md={6}>
              <LocalizationProvider dateAdapter={AdapterDateFns}>
                <DatePicker
                  label="Feedback Date"
                  value={formData.feedback_date}
                  onChange={(date) => handleDateChange('feedback_date', date)}
                  slotProps={{
                    textField: {
                      fullWidth: true,
                      helperText: 'Enter the date when feedback is expected'
                    }
                  }}
                />
              </LocalizationProvider>
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Comments"
                name="comments"
                value={formData.comments}
                onChange={handleChange}
                multiline
                rows={4}
                helperText="Add any additional notes or comments about this project"
              />
            </Grid>
            
            <Grid item xs={12}>
              <Box display="flex" justifyContent="flex-end" mt={2}>
                <Button
                  component={Link}
                  to="/projects"
                  variant="outlined"
                  sx={{ mr: 1 }}
                >
                  Cancel
                </Button>
                <Button
                  type="submit"
                  variant="contained"
                  color="primary"
                  startIcon={<SaveIcon />}
                  disabled={loading}
                >
                  {loading ? 'Saving...' : isEditing ? 'Update Project' : 'Create Project'}
                </Button>
              </Box>
            </Grid>
          </Grid>
        </form>
      </Paper>
    </Box>
  );
};

export default ProjectForm;