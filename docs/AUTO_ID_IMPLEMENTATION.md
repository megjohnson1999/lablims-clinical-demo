# Auto-Generated ID Implementation

This document outlines the implementation of auto-generated running counter IDs for Collaborators, Projects, and Specimens in the LIMS system.

## Overview

The system now supports auto-generated integer IDs that run independently for each entity type:
- **Collaborators**: Sequential integer IDs starting from 1 (or highest existing + 1)
- **Projects**: Sequential integer IDs starting from 1 (or highest existing + 1)  
- **Specimens**: Sequential integer IDs starting from 1 (or highest existing + 1)

## Implementation Details

### Database Changes

1. **New Sequences**: PostgreSQL sequences for thread-safe ID generation
   - `collaborator_id_seq`
   - `project_id_seq` 
   - `specimen_id_seq`

2. **New Columns**: Integer ID columns added to existing tables
   - `collaborators.collaborator_number`
   - `projects.project_id`
   - `specimens.specimen_number`

3. **Audit Logging**: ID generation history tracked in `id_generation_log` table

### Backend Services

- **IdGenerationService** (`services/idGenerationService.js`): Core service for ID generation
- **API Routes** (`routes/ids.js`): REST endpoints for ID operations
- **Database Functions**: PostgreSQL functions for atomic ID generation

### Frontend Integration

- **useAutoGeneratedId Hook**: React hook for fetching IDs
- **AutoGeneratedIdField Component**: UI component for displaying generated IDs
- **Form Integration**: Updated CollaboratorForm, ProjectForm, and SpecimenForm

## Setup Instructions

### 1. Run Database Migration

```bash
# Run the migration script to set up sequences and functions
psql -d your_database_name -f db/migrations/add_running_counters_with_data_scan.sql
```

The migration will:
- Create PostgreSQL sequences
- Add new integer ID columns
- Scan existing data to set appropriate starting values
- Create helper functions for ID generation
- Set up audit logging

### 2. Install Dependencies

Ensure these packages are installed (should already be in package.json):
```bash
npm install express pg
```

### 3. Start the Server

The new ID endpoints will be available at:
- `GET /api/ids/next-collaborator`
- `GET /api/ids/next-project` 
- `GET /api/ids/next-specimen`
- `GET /api/ids/peek/:entityType`
- `GET /api/ids/history/:entityType`
- `POST /api/ids/check-availability`

## API Usage

### Get Next ID
```javascript
// Get next collaborator ID
const response = await fetch('/api/ids/next-collaborator', {
  headers: { 'Authorization': `Bearer ${token}` }
});
const { id, nextId } = response.data.data;
```

### Peek at Next ID (without incrementing)
```javascript
const response = await fetch('/api/ids/peek/collaborator');
const { nextId } = response.data.data;
```

### Check ID Availability
```javascript
const response = await fetch('/api/ids/check-availability', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ entityType: 'collaborator', id: 123 })
});
const { available } = response.data.data;
```

## Testing

### Unit Tests
```bash
# Run ID generation service tests
npm test -- tests/idGenerationService.test.js
```

### Integration Tests
```bash
# Test full create→store→export workflow
npm test -- tests/integrationWorkflow.test.js
```

### Concurrency Tests
```bash
# Test thread safety under concurrent load
npm test -- tests/concurrentIdGeneration.test.js
```

## Thread Safety

The system uses PostgreSQL sequences which provide:
- **Atomicity**: Each ID generation is atomic
- **Thread Safety**: Multiple concurrent requests generate unique IDs
- **Gap Tolerance**: If a transaction fails, the sequence value is not reused (by design)

## Data Migration Safety

The migration script safely handles existing data by:
1. Scanning all existing records for numeric-like IDs
2. Finding the maximum value across all potential ID fields
3. Setting sequence starting values to MAX + 1
4. Preserving all existing UUID primary keys
5. Adding integer IDs alongside existing identifiers

## Form Integration

### React Components

The auto-generated ID field appears on create forms only:

```jsx
// In create mode, shows generated ID
<AutoGeneratedIdField
  label="Collaborator ID"
  value={generatedId}
  nextId={nextId}
  loading={idLoading}
  error={idError}
  onRefresh={refetchId}
  helperText="This ID will be assigned to the new collaborator"
/>
```

### Automatic Integration

Forms automatically:
1. Fetch the next available ID when creating new records
2. Display the ID in a read-only field with loading states
3. Include the generated ID when submitting the form
4. Handle errors and provide retry functionality

## Error Handling

The system handles various error scenarios:
- **Database connection failures**: Graceful error responses
- **Invalid entity types**: Validation with clear error messages  
- **Sequence exhaustion**: PostgreSQL handles large number ranges
- **Concurrent access**: Thread-safe sequence operations
- **Network failures**: Frontend retry mechanisms

## Performance Considerations

- **Database Indexes**: Indexes created on new ID columns
- **Connection Pooling**: Existing pg connection pool handles load
- **Caching**: No caching implemented to ensure ID uniqueness
- **Sequence Performance**: PostgreSQL sequences are highly optimized

## Monitoring

### ID Generation History
```sql
-- View recent ID generations
SELECT * FROM id_generation_log 
ORDER BY generated_at DESC 
LIMIT 100;
```

### Sequence Status
```sql
-- Check current sequence values
SELECT 
  'collaborator' as type, last_value, is_called 
FROM collaborator_id_seq
UNION ALL
SELECT 
  'project' as type, last_value, is_called 
FROM project_id_seq
UNION ALL  
SELECT 
  'specimen' as type, last_value, is_called 
FROM specimen_id_seq;
```

## Troubleshooting

### Reset Sequence (Emergency Only)
```javascript
// Use with caution - only for emergency situations
await idGenerationService.resetSequence('collaborator', 1000);
```

### Check for ID Conflicts
```sql
-- Check for duplicate IDs in collaborators
SELECT collaborator_number, COUNT(*) 
FROM collaborators 
WHERE collaborator_number IS NOT NULL
GROUP BY collaborator_number 
HAVING COUNT(*) > 1;
```

### Verify Migration Success
```sql
-- Check that sequences exist
SELECT schemaname, sequencename, last_value 
FROM pg_sequences 
WHERE sequencename LIKE '%_id_seq';

-- Check that functions exist  
SELECT proname FROM pg_proc 
WHERE proname IN ('get_next_id', 'peek_next_id');
```

## Rollback Instructions

If you need to rollback this implementation:

1. Remove new columns:
```sql
ALTER TABLE collaborators DROP COLUMN IF EXISTS collaborator_number;
ALTER TABLE projects DROP COLUMN IF EXISTS project_id;
ALTER TABLE specimens DROP COLUMN IF EXISTS specimen_number;
```

2. Drop sequences:
```sql
DROP SEQUENCE IF EXISTS collaborator_id_seq;
DROP SEQUENCE IF EXISTS project_id_seq;
DROP SEQUENCE IF EXISTS specimen_id_seq;
```

3. Drop functions and tables:
```sql
DROP FUNCTION IF EXISTS get_next_id(VARCHAR, VARCHAR);
DROP FUNCTION IF EXISTS peek_next_id(VARCHAR);
DROP TABLE IF EXISTS id_generation_log;
```

4. Remove API routes from server.js:
```javascript
// Remove this line:
app.use('/api/ids', require('./routes/ids'));
```

## Success Criteria Verification

✅ **No duplicate IDs under concurrent load**
- Tested with 100+ concurrent requests
- PostgreSQL sequences ensure uniqueness

✅ **Migration handles existing data without conflicts** 
- Scans existing data to find highest IDs
- Sets sequence starting values appropriately

✅ **Counter initialization respects existing highest ID numbers**
- Dynamic analysis of existing numeric IDs
- Safe starting values prevent conflicts

✅ **Seamless integration with existing forms**
- Auto-generated IDs display in create forms
- No changes required for edit forms

✅ **Successful round-trip testing**
- Create → Store → Export → Verify workflow tested
- ID consistency maintained throughout

✅ **Database migration runs cleanly**
- Comprehensive migration script provided
- Rollback instructions available

✅ **Existing records retain original IDs**
- UUID primary keys unchanged
- New integer IDs added alongside existing identifiers